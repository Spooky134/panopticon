<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Video stream via WebRTC</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
  <script defer src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
  <style>
    body { background-color: #f8f9fa; padding: 20px; }
    .container { max-width: 1200px; }
    .video-container {
      background-color: #fff;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      padding: 20px;
      margin-bottom: 20px;
    }
    .video-wrapper { position: relative; margin-bottom: 15px; }
    .video-title {
      position: absolute;
      top: 10px;
      left: 10px;
      background-color: rgba(0,0,0,0.7);
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 14px;
      z-index: 10;
    }
    video {
      width: 100%;
      height: 300px;
      background-color: #000;
      border-radius: 5px;
      transform: scaleX(-1);
    }
    .metrics {
      font-size: 0.9rem;
      color: #555;
      margin-top: 5px;
    }
    .status-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
      background-color: #6c757d;
    }
    .status-active {
      background-color: #198754;
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1 class="display-5 fw-bold text-center mb-4">Video stream via WebRTC</h1>

    <div class="row">
      <div class="col-md-6">
        <div class="video-container">
          <div class="video-wrapper">
            <div class="video-title">Original Stream</div>
            <video id="localVideo" autoplay playsinline muted></video>
          </div>
          <div class="text-center">
            <span id="localStatus" class="badge bg-secondary">Inactive</span>
            <div class="metrics" id="localMetrics"></div>
          </div>
        </div>
      </div>
      <div class="col-md-6">
        <div class="video-container">
          <div class="video-wrapper">
            <div class="video-title">Processed Stream</div>
            <video id="remoteVideo" autoplay playsinline></video>
          </div>
          <div class="text-center">
            <span id="remoteStatus" class="badge bg-secondary">Inactive</span>
            <div class="metrics" id="remoteMetrics"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="text-center mt-4">
      <button id="toggleButton" class="btn btn-primary btn-lg">
        <span class="status-indicator"></span> START STREAM
      </button>
      <div class="mt-2">
        <small class="text-muted" id="connectionInfo">Ready to connect</small>
      </div>
    </div>
  </div>

  <script>
    const CONFIG = {
      vstreamServiceURL: "{{ vstream_service_url }}",
      turnURL: "{{ turn_url }}",
      turnUsername: "{{ turn_username }}",
      turnPassword: "{{ turn_password }}",
      authToken: "{{ auth_token }}"
    };

    let localStream, pc, isStreaming = false;
    const toggleButton = document.getElementById("toggleButton");
    const localVideo = document.getElementById("localVideo");
    const remoteVideo = document.getElementById("remoteVideo");
    const localStatus = document.getElementById("localStatus");
    const remoteStatus = document.getElementById("remoteStatus");
    const connectionInfo = document.getElementById("connectionInfo");
    const localMetrics = document.getElementById("localMetrics");
    const remoteMetrics = document.getElementById("remoteMetrics");
    const statusIndicator = document.querySelector(".status-indicator");

    toggleButton.onclick = async () => {
      if (!isStreaming) {
        try {
          toggleButton.disabled = true;
          toggleButton.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Connecting...';

          localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
          localVideo.srcObject = localStream;
          localStatus.textContent = "Active";
          localStatus.className = "badge bg-success";

          pc = new RTCPeerConnection({
            iceServers: [
              { urls: ["stun:stun.l.google.com:19302"] },
              { urls: [CONFIG.turnURL], username: CONFIG.turnUsername, credential: CONFIG.turnPassword }
            ]
          });

          localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

          pc.ontrack = event => {
            remoteVideo.srcObject = event.streams[0];
            remoteStatus.textContent = "Active";
            remoteStatus.className = "badge bg-success";
          };

          pc.onconnectionstatechange = () => {
            if (pc.connectionState === "connected") {
              connectionInfo.textContent = "Connected ✅";
              monitorStats(); // запускаем мониторинг
            }
          };

          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);

          const SERVER_URL = CONFIG.vstreamServiceURL;
          const response = await fetch(SERVER_URL, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${CONFIG.authToken}`
                },
            body: JSON.stringify({ sdp: offer.sdp, type: offer.type })
          });

          const answer = await response.json();
          await pc.setRemoteDescription(new RTCSessionDescription(answer));

          isStreaming = true;
          toggleButton.innerHTML = '<span class="status-indicator status-active"></span> Stop Stream';
          toggleButton.className = "btn btn-danger btn-lg";
          statusIndicator.classList.add("status-active");

        } catch (err) {
          console.error(err);
          connectionInfo.textContent = `Error: ${err.message}`;
        } finally {
          toggleButton.disabled = false;
        }
      } else {
        if (localStream) localStream.getTracks().forEach(t => t.stop());
        if (pc) pc.close();

        localVideo.srcObject = null;
        remoteVideo.srcObject = null;
        localStatus.textContent = "Inactive";
        remoteStatus.textContent = "Inactive";
        localStatus.className = "badge bg-secondary";
        remoteStatus.className = "badge bg-secondary";
        connectionInfo.textContent = "Stream stopped";

        isStreaming = false;
        toggleButton.innerHTML = '<span class="status-indicator"></span> START STREAM';
        toggleButton.className = "btn btn-primary btn-lg";
        statusIndicator.classList.remove("status-active");
      }
    };

    // === Исправленный мониторинг производительности ===
        let lastOutbound = { bytesSent: 0, timestamp: 0 };
        let lastInbound = { framesDecoded: 0, timestamp: 0 };

        async function monitorStats() {
          if (!pc || pc.connectionState !== "connected") {
            setTimeout(monitorStats, 1000);
            return;
          }

          const stats = await pc.getStats();

          let fpsOut = 0, fpsIn = 0, rtt = 0, bitrateKbps = 0;

          stats.forEach(report => {
            // исходящий поток (клиент → gateway)
            if (report.type === "outbound-rtp" && report.kind === "video") {
              if (report.bytesSent && report.timestamp) {
                if (lastOutbound.timestamp) {
                  const deltaBytes = report.bytesSent - lastOutbound.bytesSent;
                  const deltaTime = (report.timestamp - lastOutbound.timestamp) / 1000;
                  bitrateKbps = (deltaBytes * 8) / 1000 / deltaTime; // кбит/с
                }
                lastOutbound = {
                  bytesSent: report.bytesSent,
                  timestamp: report.timestamp
                };
              }
              if (report.framesPerSecond) fpsOut = report.framesPerSecond;
              if (report.roundTripTime) rtt = report.roundTripTime * 1000;
            }

            // входящий поток (gateway → клиент)
            if (report.type === "inbound-rtp" && report.kind === "video") {
              if (report.framesDecoded && report.timestamp) {
                if (lastInbound.timestamp) {
                  const deltaFrames = report.framesDecoded - lastInbound.framesDecoded;
                  const deltaTime = (report.timestamp - lastInbound.timestamp) / 1000;
                  fpsIn = deltaFrames / deltaTime;
                }
                lastInbound = {
                  framesDecoded: report.framesDecoded,
                  timestamp: report.timestamp
                };
              }
            }
          });

          // вывод
          localMetrics.textContent = `FPS (out): ${fpsOut.toFixed(1)} | Bitrate: ${bitrateKbps.toFixed(1)} kbps`;
          remoteMetrics.textContent = `FPS (in): ${fpsIn.toFixed(1)} | RTT: ${rtt.toFixed(1)} ms`;
          connectionInfo.textContent = `End-to-end latency ≈ ${rtt.toFixed(1)} ms`;

          setTimeout(monitorStats, 1000);
        }

  </script>
</body>
</html>
