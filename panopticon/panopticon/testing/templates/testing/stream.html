{% extends "testing/base.html" %}
{% load static %}

{% block title %}Video stream via WebRTC{% endblock %}

{% block content %}
<div class="container">
  <h1 class="display-5 fw-bold text-center mb-4">Video stream via WebRTC</h1>

  <div class="row">
    <div class="col-md-6">
      <div class="video-container">
        <div class="video-wrapper">
          <div class="video-title">Original Stream</div>
          <video id="localVideo" autoplay playsinline muted></video>
        </div>
        <div class="text-center">
          <span id="localStatus" class="badge bg-secondary">Inactive</span>
          <div class="metrics" id="localMetrics"></div>
        </div>
      </div>
    </div>
    <div class="col-md-6">
      <div class="video-container">
        <div class="video-wrapper">
          <div class="video-title">Processed Stream</div>
          <video id="remoteVideo" autoplay playsinline></video>
        </div>
        <div class="text-center">
          <span id="remoteStatus" class="badge bg-secondary">Inactive</span>
          <div class="metrics" id="remoteMetrics"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="text-center mt-4">
    <button id="toggleButton" class="btn btn-primary btn-lg">
      <span class="status-indicator"></span> START STREAM
    </button>
    <div class="mt-2">
      <small class="text-muted" id="connectionInfo">Ready to connect</small>
    </div>
  </div>
</div>
{% endblock %}

{% block javascript %}
<script>
  const CONFIG = {
    vstreamServiceURL: "{{ vstream_service_url }}",
    turnURL: "{{ turn_url }}",
    turnUsername: "{{ turn_username }}",
    turnPassword: "{{ turn_password }}",
    authToken: "{{ auth_token }}"
  };

  // ... остальной JavaScript код без изменений ...
  let localStream, pc, isStreaming = false;
  const toggleButton = document.getElementById("toggleButton");
  const localVideo = document.getElementById("localVideo");
  const remoteVideo = document.getElementById("remoteVideo");
  const localStatus = document.getElementById("localStatus");
  const remoteStatus = document.getElementById("remoteStatus");
  const connectionInfo = document.getElementById("connectionInfo");
  const localMetrics = document.getElementById("localMetrics");
  const remoteMetrics = document.getElementById("remoteMetrics");
  const statusIndicator = document.querySelector(".status-indicator");

  toggleButton.onclick = async () => {
    if (!isStreaming) {
      try {
        toggleButton.disabled = true;
        toggleButton.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Connecting...';

        localStream = await navigator.mediaDevices.getUserMedia({
                video: {
                  width: { ideal: 1280 },
                  height: { ideal: 720 },
                  bitrate: { max: 2000000 },
                  frameRate: { ideal: 30, max: 30 }

                },
                audio: false
              });
        // ---- VIDEO TIMESTAMP ENCODING ----
// берём оригинальный трек
        const inputTrack = localStream.getVideoTracks()[0];

        // создаём процессор и генератор
        const processor = new MediaStreamTrackProcessor({ track: inputTrack });
        const generator = new MediaStreamTrackGenerator({ kind: "video" });

        const reader = processor.readable.getReader();
        const writer = generator.writable.getWriter();

        // запускаем цикл обработки кадров
        (async () => {
          while (true) {
            const { value: frame } = await reader.read();
            if (!frame) break;

            const ts = Math.floor(performance.now());  // timestamp ms

            // рисуем кадр на canvas
            const bitmap = await createImageBitmap(frame);
            const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);
            const ctx = canvas.getContext("2d");
            ctx.drawImage(bitmap, 0, 0);

            const img = ctx.getImageData(0, 0, 8, 1);

            let t = BigInt(ts);

            for (let i = 0; i < 8; i++) {
                img.data[i * 4 + 3] = Number(t & 0xFFn);  // пишем в ALPHA
                t >>= 8n;
            }

            ctx.putImageData(img, 0, 0);

            // создаём новый кадр
            const newFrame = new VideoFrame(canvas, {
              timestamp: frame.timestamp,   // сохраняем PTS
            });

            frame.close();
            await writer.write(newFrame);
          }
        })();

        // заменяем трек в стриме
        localStream.removeTrack(inputTrack);
        localStream.addTrack(generator);

        
        localVideo.srcObject = localStream;
        localStatus.textContent = "Active";
        localStatus.className = "badge bg-success";

        pc = new RTCPeerConnection({
          iceServers: [
            { urls: ["stun:stun.l.google.com:19302"] },
            { urls: [CONFIG.turnURL], username: CONFIG.turnUsername, credential: CONFIG.turnPassword }
          ]
        });

        {% comment %} localStream.getTracks().forEach(track => pc.addTrack(track, localStream)); {% endcomment %}
        pc.addTrack(generator, localStream);

        pc.ontrack = event => {
          remoteVideo.srcObject = event.streams[0];
          remoteStatus.textContent = "Active";
          remoteStatus.className = "badge bg-success";
        };

        pc.onconnectionstatechange = () => {
          if (pc.connectionState === "connected") {
            connectionInfo.textContent = "Connected ✅";
            monitorStats();
          }
        };

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        const SERVER_URL = CONFIG.vstreamServiceURL;
        const response = await fetch(SERVER_URL, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${CONFIG.authToken}`
          },
          body: JSON.stringify({ sdp: offer.sdp, type: offer.type })
        });

        const answer = await response.json();
        await pc.setRemoteDescription(new RTCSessionDescription(answer));

        isStreaming = true;
        toggleButton.innerHTML = '<span class="status-indicator status-active"></span> Stop Stream';
        toggleButton.className = "btn btn-danger btn-lg";
        statusIndicator.classList.add("status-active");

      } catch (err) {
        console.error(err);
        connectionInfo.textContent = `Error: ${err.message}`;
      } finally {
        toggleButton.disabled = false;
      }
    } else {
      if (localStream) localStream.getTracks().forEach(t => t.stop());
      if (pc) pc.close();

      localVideo.srcObject = null;
      remoteVideo.srcObject = null;
      localStatus.textContent = "Inactive";
      remoteStatus.textContent = "Inactive";
      localStatus.className = "badge bg-secondary";
      remoteStatus.className = "badge bg-secondary";
      connectionInfo.textContent = "Stream stopped";

      isStreaming = false;
      toggleButton.innerHTML = '<span class="status-indicator"></span> START STREAM';
      toggleButton.className = "btn btn-primary btn-lg";
      statusIndicator.classList.remove("status-active");
    }
  };

  let lastOutbound = { bytesSent: 0, timestamp: 0 };
  let lastInbound = { framesDecoded: 0, timestamp: 0 };

  async function monitorStats() {
    if (!pc || pc.connectionState !== "connected") {
      setTimeout(monitorStats, 1000);
      return;
    }

    const stats = await pc.getStats();
    let fpsOut = 0, fpsIn = 0, rtt = 0, bitrateKbps = 0;

    stats.forEach(report => {
      if (report.type === "outbound-rtp" && report.kind === "video") {
        if (report.bytesSent && report.timestamp) {
          if (lastOutbound.timestamp) {
            const deltaBytes = report.bytesSent - lastOutbound.bytesSent;
            const deltaTime = (report.timestamp - lastOutbound.timestamp) / 1000;
            bitrateKbps = (deltaBytes * 8) / 1000 / deltaTime;
          }
          lastOutbound = {
            bytesSent: report.bytesSent,
            timestamp: report.timestamp
          };
        }
        if (report.framesPerSecond) fpsOut = report.framesPerSecond;
        if (report.roundTripTime) rtt = report.roundTripTime * 1000;
      }

      if (report.type === "inbound-rtp" && report.kind === "video") {
        if (report.framesDecoded && report.timestamp) {
          if (lastInbound.timestamp) {
            const deltaFrames = report.framesDecoded - lastInbound.framesDecoded;
            const deltaTime = (report.timestamp - lastInbound.timestamp) / 1000;
            fpsIn = deltaFrames / deltaTime;
          }
          lastInbound = {
            framesDecoded: report.framesDecoded,
            timestamp: report.timestamp
          };
        }
      }
    });

    localMetrics.textContent = `FPS (out): ${fpsOut.toFixed(1)} | Bitrate: ${bitrateKbps.toFixed(1)} kbps`;
    remoteMetrics.textContent = `FPS (in): ${fpsIn.toFixed(1)} | RTT: ${rtt.toFixed(1)} ms`;
    connectionInfo.textContent = `End-to-end latency ≈ ${rtt.toFixed(1)} ms`;

    setTimeout(monitorStats, 1000);
  }
</script>
{% endblock %}