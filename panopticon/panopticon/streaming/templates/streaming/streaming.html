{% extends "streaming/base.html" %}
{% load static %}

{% block title %}Video stream via WebRTC{% endblock %}

{% block content %}
<div class="container">
  <h1 class="display-5 fw-bold text-center mb-4">Video stream via WebRTC</h1>

  <div class="row">
    <div class="col-md-6">
      <div class="video-container">
        <div class="video-wrapper">
          <div class="video-title">Original Stream</div>
          <video id="localVideo" autoplay playsinline muted></video>
        </div>
        <div class="text-center">
          <span id="localStatus" class="badge bg-secondary">Inactive</span>
          <div class="metrics" id="localMetrics"></div>
        </div>
      </div>
    </div>
    <div class="col-md-6">
      <div class="video-container">
        <div class="video-wrapper">
          <div class="video-title">Processed Stream</div>
          <video id="remoteVideo" autoplay playsinline></video>
        </div>
        <div class="text-center">
          <span id="remoteStatus" class="badge bg-secondary">Inactive</span>
          <div class="metrics" id="remoteMetrics"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="text-center mt-4">
    <button id="toggleButton" class="btn btn-primary btn-lg">
      <span class="status-indicator"></span> START STREAM
    </button>
    <div class="mt-2">
      <small class="text-muted" id="connectionInfo">Ready to connect</small>
    </div>
  </div>
</div>
{% endblock %}

{% block javascript %}
<script>
  const CONFIG = {
    offerURL: "{{ offer_url }}",
    stopURL: "{{ stop_url }}",
    turnURL: "{{ turn_url }}",
    turnUsername: "{{ turn_username }}",
    turnPassword: "{{ turn_password }}"
  };

  // ... остальной JavaScript код без изменений ...
  let localStream, pc, isStreaming = false;
  const toggleButton = document.getElementById("toggleButton");
  const localVideo = document.getElementById("localVideo");
  const remoteVideo = document.getElementById("remoteVideo");
  const localStatus = document.getElementById("localStatus");
  const remoteStatus = document.getElementById("remoteStatus");
  const connectionInfo = document.getElementById("connectionInfo");
  const localMetrics = document.getElementById("localMetrics");
  const remoteMetrics = document.getElementById("remoteMetrics");
  const statusIndicator = document.querySelector(".status-indicator");

  toggleButton.onclick = async () => {
    if (!isStreaming) {
      try {
        toggleButton.disabled = true;
        toggleButton.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Connecting...';

        localStream = await navigator.mediaDevices.getUserMedia({
                video: {
                  width: { ideal: 1280 },
                  height: { ideal: 720 },
                  bitrate: { max: 2000000 },
                  frameRate: { ideal: 30, max: 30 }

                },
                audio: false
              });

        
        localVideo.srcObject = localStream;
        localStatus.textContent = "Active";
        localStatus.className = "badge bg-success";

        pc = new RTCPeerConnection({
          iceServers: [
            { urls: ["stun:stun.l.google.com:19302"] },
            { urls: [CONFIG.turnURL], username: CONFIG.turnUsername, credential: CONFIG.turnPassword }
          ]
        });

        localStream.getTracks().forEach(track => pc.addTrack(track, localStream))

        pc.ontrack = event => {
          remoteVideo.srcObject = event.streams[0];
          remoteStatus.textContent = "Active";
          remoteStatus.className = "badge bg-success";
        };

        pc.onconnectionstatechange = () => {
          if (pc.connectionState === "connected") {
            connectionInfo.textContent = "Connected ✅";
            monitorStats();
          }
        };

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        const csrftoken = getCookie("csrftoken");
        const SERVER_URL = CONFIG.offerURL;
        const response = await fetch(SERVER_URL, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRFToken": csrftoken
          },
          body: JSON.stringify({ sdp: offer.sdp, type: offer.type })
        });
        
        

        const answer = await response.json();
        await pc.setRemoteDescription(new RTCSessionDescription(answer));

        isStreaming = true;
        toggleButton.innerHTML = '<span class="status-indicator status-active"></span> Stop Stream';
        toggleButton.className = "btn btn-danger btn-lg";
        statusIndicator.classList.add("status-active");

      } catch (err) {
        console.error(err);
        connectionInfo.textContent = `Error: ${err.message}`;
      } finally {
        toggleButton.disabled = false;
      }
    } 
    else {
        toggleButton.disabled = true;
        toggleButton.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Stopping...';

        
        try {
          // const csrftoken = getCookie("csrftoken");
          // response = await fetch(CONFIG.stopURL, {
          //   method: "POST",
          //   headers: {
          //     "X-CSRFToken": csrftoken
          //   }
          // });
          //
          // if (!response.ok) {
          //   throw new Error(`Server responded with status: ${response.status}`);
          // }

          if (pc) {
            pc.close();
          }

          if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
          }

          localVideo.srcObject = null;
          remoteVideo.srcObject = null;
          localStatus.textContent = "Inactive";
          remoteStatus.textContent = "Inactive";
          localStatus.className = "badge bg-secondary";
          remoteStatus.className = "badge bg-secondary";
          connectionInfo.textContent = "Stream stopped";

          isStreaming = false;
          toggleButton.innerHTML = '<span class="status-indicator"></span> START STREAM';
          toggleButton.className = "btn btn-primary btn-lg";
          statusIndicator.classList.remove("status-active");
        } 
        catch (e) {
          console.error("Stop request failed:", e);
          connectionInfo.textContent = `Stop error: ${e.message}`;
        }
        finally {
          // 5. Всегда очищаем UI и разблокируем кнопку
          localVideo.srcObject = null;
          remoteVideo.srcObject = null;
          localStatus.textContent = "Inactive";
          remoteStatus.textContent = "Inactive";
          localStatus.className = "badge bg-secondary";
          remoteStatus.className = "badge bg-secondary";
          connectionInfo.textContent = "Stream stopped";

          isStreaming = false;
          toggleButton.innerHTML = '<span class="status-indicator"></span> START STREAM';
          toggleButton.className = "btn btn-primary btn-lg";
          statusIndicator.classList.remove("status-active");
          toggleButton.disabled = false;  // ← Важно: разблокируем кнопку
        }
      }
  };

  let lastOutbound = { bytesSent: 0, timestamp: 0 };
  let lastInbound = { framesDecoded: 0, timestamp: 0 };

  async function monitorStats() {
    if (!pc || pc.connectionState !== "connected") {
      setTimeout(monitorStats, 1000);
      return;
    }

    const stats = await pc.getStats();
    let fpsOut = 0, fpsIn = 0, rtt = 0, bitrateKbps = 0;

    stats.forEach(report => {
      if (report.type === "outbound-rtp" && report.kind === "video") {
        if (report.bytesSent && report.timestamp) {
          if (lastOutbound.timestamp) {
            const deltaBytes = report.bytesSent - lastOutbound.bytesSent;
            const deltaTime = (report.timestamp - lastOutbound.timestamp) / 1000;
            bitrateKbps = (deltaBytes * 8) / 1000 / deltaTime;
          }
          lastOutbound = {
            bytesSent: report.bytesSent,
            timestamp: report.timestamp
          };
        }
        if (report.framesPerSecond) fpsOut = report.framesPerSecond;
        if (report.roundTripTime) rtt = report.roundTripTime * 1000;
      }

      if (report.type === "inbound-rtp" && report.kind === "video") {
        if (report.framesDecoded && report.timestamp) {
          if (lastInbound.timestamp) {
            const deltaFrames = report.framesDecoded - lastInbound.framesDecoded;
            const deltaTime = (report.timestamp - lastInbound.timestamp) / 1000;
            fpsIn = deltaFrames / deltaTime;
          }
          lastInbound = {
            framesDecoded: report.framesDecoded,
            timestamp: report.timestamp
          };
        }
      }
    });

    localMetrics.textContent = `FPS (out): ${fpsOut.toFixed(1)} | Bitrate: ${bitrateKbps.toFixed(1)} kbps`;
    remoteMetrics.textContent = `FPS (in): ${fpsIn.toFixed(1)} | RTT: ${rtt.toFixed(1)} ms`;
    connectionInfo.textContent = `End-to-end latency ≈ ${rtt.toFixed(1)} ms`;

    setTimeout(monitorStats, 1000);
  }
  function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
  }
</script>
{% endblock %}